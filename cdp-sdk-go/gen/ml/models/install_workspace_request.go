// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InstallWorkspaceRequest Request object for the InstallWorkspace method.
//
// swagger:model InstallWorkspaceRequest
type InstallWorkspaceRequest struct {

	// Adds an additional runtime repo for the workspace.
	AdditionalRuntimeRepo string `json:"additionalRuntimeRepo,omitempty"`

	// The whitelist of CIDR blocks which can access the API server.
	AuthorizedIPRanges []string `json:"authorizedIPRanges"`

	// The cluster CRN to install CML on.
	CdpClusterCrn string `json:"cdpClusterCrn,omitempty"`

	// The Kubeconfig of the legacy CDSW instance.
	CdswKubeconfig string `json:"cdswKubeconfig,omitempty"`

	// Toggle for cdsw migration preflight validation
	CdswMigrationMode string `json:"cdswMigrationMode,omitempty"`

	// Legacy CDSW to PvC migration timeout, in minutes.
	CdswMigrationTimeoutMinutes int32 `json:"cdswMigrationTimeoutMinutes,omitempty"`

	// Customer managed master key ARN for volume encryption.
	CustomerKMSKeyArn string `json:"customerKMSKeyArn,omitempty"`

	// The boolean flag to disable SSO authentication. By default, this flag is disabled.
	DisableSSO bool `json:"disableSSO,omitempty"`

	// The boolean flag to disable TLS setup for workspace. By default, the TLS is enabled.
	DisableTLS bool `json:"disableTLS,omitempty"`

	// Enables Cloudera Machine Learning governance by integrating with Cloudera Atlas. By default, this flag is disabled.
	EnableGovernance bool `json:"enableGovernance,omitempty"`

	// Enables the model metrics service for exporting metrics for models to a metrics store.
	EnableModelMetrics bool `json:"enableModelMetrics,omitempty"`

	// The boolean flag is used to enable monitoring. By default, monitoring is disabled.
	EnableMonitoring bool `json:"enableMonitoring,omitempty"`

	// The boolean flag is used to enable yunikorn scheduling. By default, yunikorn scheduling is disabled.
	EnableYunikorn bool `json:"enableYunikorn,omitempty"`

	// The name of the environment for the workspace to install in.
	// Required: true
	EnvironmentName *string `json:"environmentName"`

	// Optional configurations for an existing Postgres to export model metrics to.
	ExistingDatabaseConfig *ExistingDatabaseConfig `json:"existingDatabaseConfig,omitempty"`

	// Optionally use an existing NFS by providing the hostname and desired path (Azure and Private Cloud only).
	ExistingNFS string `json:"existingNFS,omitempty"`

	// Image catalog for custom AMI.
	ImageCatalog *ImageCatalog `json:"imageCatalog,omitempty"`

	// Optionally use an existing K8s cluster by providing the kubeconfig.
	Kubeconfig string `json:"kubeconfig,omitempty"`

	// The whitelist of IPs for load balancer.
	LoadBalancerIPWhitelists []string `json:"loadBalancerIPWhitelists"`

	// The kerberos principal used for ML Governance service.
	MlGovernancePrincipal string `json:"mlGovernancePrincipal,omitempty"`

	// The version of ML workload app to install.
	MlVersion string `json:"mlVersion,omitempty"`

	// The Kubernetes namespace in which to install the workspace.
	Namespace string `json:"namespace,omitempty"`

	// The NFS Protocol version of the NFS server to use for Azure and Private Cloud.
	NfsVersion string `json:"nfsVersion,omitempty"`

	// Whether to perform a legacy CDSW to PvC migration (Private Cloud only).
	PerformCdswMigration bool `json:"performCdswMigration,omitempty"`

	// Skip pre-flight validations if requested.
	SkipValidation bool `json:"skipValidation,omitempty"`

	// The static subdomain to be used for the workspace.
	StaticSubdomain string `json:"staticSubdomain,omitempty"`

	// The list of subnets used for the load balancer that CML creates.
	SubnetsForLoadBalancers []string `json:"subnetsForLoadBalancers"`

	// Whether to use legacy EFS provisioner to access EFS and create PVs thereon.
	UseLegacyEFS bool `json:"useLegacyEFS,omitempty"`

	// Whether to use legacy storage drivers.
	UseLegacyStorageDrivers bool `json:"useLegacyStorageDrivers,omitempty"`

	// The boolean flag to request a public load balancer. By default, a private load balancer is used.
	UsePublicLoadBalancer bool `json:"usePublicLoadBalancer,omitempty"`

	// Whether to use spot instances for CDSW infrastructure nodes.
	UseSpotInstancesForMlInfra bool `json:"useSpotInstancesForMlInfra,omitempty"`

	// Whether to whitelist only 'authorizedIPRanges' given or all public IPs.
	WhitelistAuthorizedIPRanges bool `json:"whitelistAuthorizedIPRanges,omitempty"`

	// The name of the workspace to create.
	// Required: true
	WorkspaceName *string `json:"workspaceName"`
}

// Validate validates this install workspace request
func (m *InstallWorkspaceRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEnvironmentName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExistingDatabaseConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImageCatalog(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWorkspaceName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InstallWorkspaceRequest) validateEnvironmentName(formats strfmt.Registry) error {

	if err := validate.Required("environmentName", "body", m.EnvironmentName); err != nil {
		return err
	}

	return nil
}

func (m *InstallWorkspaceRequest) validateExistingDatabaseConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ExistingDatabaseConfig) { // not required
		return nil
	}

	if m.ExistingDatabaseConfig != nil {
		if err := m.ExistingDatabaseConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("existingDatabaseConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("existingDatabaseConfig")
			}
			return err
		}
	}

	return nil
}

func (m *InstallWorkspaceRequest) validateImageCatalog(formats strfmt.Registry) error {
	if swag.IsZero(m.ImageCatalog) { // not required
		return nil
	}

	if m.ImageCatalog != nil {
		if err := m.ImageCatalog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("imageCatalog")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("imageCatalog")
			}
			return err
		}
	}

	return nil
}

func (m *InstallWorkspaceRequest) validateWorkspaceName(formats strfmt.Registry) error {

	if err := validate.Required("workspaceName", "body", m.WorkspaceName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this install workspace request based on the context it is used
func (m *InstallWorkspaceRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExistingDatabaseConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImageCatalog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InstallWorkspaceRequest) contextValidateExistingDatabaseConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ExistingDatabaseConfig != nil {
		if err := m.ExistingDatabaseConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("existingDatabaseConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("existingDatabaseConfig")
			}
			return err
		}
	}

	return nil
}

func (m *InstallWorkspaceRequest) contextValidateImageCatalog(ctx context.Context, formats strfmt.Registry) error {

	if m.ImageCatalog != nil {
		if err := m.ImageCatalog.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("imageCatalog")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("imageCatalog")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *InstallWorkspaceRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InstallWorkspaceRequest) UnmarshalBinary(b []byte) error {
	var res InstallWorkspaceRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateWorkspaceRequest Request object for the CreateWorkspace method.
//
// swagger:model CreateWorkspaceRequest
type CreateWorkspaceRequest struct {

	// The boolean flag to disable SSO authentication. By default this flag is disabled.
	DisableSSO bool `json:"disableSSO,omitempty"`

	// The boolean flag to disable TLS setup for workspace. By default the TLS is enabled.
	DisableTLS bool `json:"disableTLS,omitempty"`

	// Enables Cloudera Machine Learning governance by integrating with Cloudera Atlas. By default, this flag is disabled.
	EnableGovernance bool `json:"enableGovernance,omitempty"`

	// Enables the model metrics service for exporting metrics for models to a metrics store.
	EnableModelMetrics bool `json:"enableModelMetrics,omitempty"`

	// The boolean flag is used to enable mlonitoring. By default monitoring is disabled.
	EnableMonitoring bool `json:"enableMonitoring,omitempty"`

	// The boolean flag is used to enable yunikorn scheduling. By default yunikorn scheduling is disabled.
	EnableYunikorn bool `json:"enableYunikorn,omitempty"`

	// The environment for the workspace to create.
	// Required: true
	EnvironmentName *string `json:"environmentName"`

	// Optional configurations for an existing Postgres to export model metrics to.
	ExistingDatabaseConfig *ExistingDatabaseConfig `json:"existingDatabaseConfig,omitempty"`

	// Optionally use an existing NFS by providing the hostname and desired path (Azure and Private Cloud only).
	ExistingNFS string `json:"existingNFS,omitempty"`

	// Optionally use an existing K8s cluster by providing the kubeconfig.
	Kubeconfig string `json:"kubeconfig,omitempty"`

	// The whitelist of ips for loadBalancer.
	LoadBalancerIPWhitelists []string `json:"loadBalancerIPWhitelists"`

	// The version of ML workload app to install.
	MlVersion string `json:"mlVersion,omitempty"`

	// The Kubernetes namespace in which to install the workspace (Private Cloud only)
	Namespace string `json:"namespace,omitempty"`

	// The NFS version of the NFS host we are using for Azure.
	NfsVersion string `json:"nfsVersion,omitempty"`

	// The request for Kubernetes workspace provision.
	ProvisionK8sRequest *ProvisionK8sRequest `json:"provisionK8sRequest,omitempty"`

	// Optional set of subnet IDs for cluster to use
	Subnets []string `json:"subnets"`

	// The boolean flag to request public load balancer. By default private load balancer is used.
	UsePublicLoadBalancer bool `json:"usePublicLoadBalancer,omitempty"`

	// Whether to use spot instances for Liftie infrastructure nodes.
	UseSpotInstancesForLiftieInfra bool `json:"useSpotInstancesForLiftieInfra,omitempty"`

	// Whether to use spot instances for CDSW infrastructure nodes.
	UseSpotInstancesForMlInfra bool `json:"useSpotInstancesForMlInfra,omitempty"`

	// The name of the workspace to create.
	// Required: true
	WorkspaceName *string `json:"workspaceName"`
}

// Validate validates this create workspace request
func (m *CreateWorkspaceRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEnvironmentName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExistingDatabaseConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvisionK8sRequest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWorkspaceName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateWorkspaceRequest) validateEnvironmentName(formats strfmt.Registry) error {

	if err := validate.Required("environmentName", "body", m.EnvironmentName); err != nil {
		return err
	}

	return nil
}

func (m *CreateWorkspaceRequest) validateExistingDatabaseConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.ExistingDatabaseConfig) { // not required
		return nil
	}

	if m.ExistingDatabaseConfig != nil {
		if err := m.ExistingDatabaseConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("existingDatabaseConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CreateWorkspaceRequest) validateProvisionK8sRequest(formats strfmt.Registry) error {

	if swag.IsZero(m.ProvisionK8sRequest) { // not required
		return nil
	}

	if m.ProvisionK8sRequest != nil {
		if err := m.ProvisionK8sRequest.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("provisionK8sRequest")
			}
			return err
		}
	}

	return nil
}

func (m *CreateWorkspaceRequest) validateWorkspaceName(formats strfmt.Registry) error {

	if err := validate.Required("workspaceName", "body", m.WorkspaceName); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateWorkspaceRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateWorkspaceRequest) UnmarshalBinary(b []byte) error {
	var res CreateWorkspaceRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
